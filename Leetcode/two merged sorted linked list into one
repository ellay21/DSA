struct ListNode {
      int val;
      ListNode *next;
      ListNode() : val(0), next(nullptr) {}
      ListNode(int x) : val(x), next(nullptr) {}
      ListNode(int x, ListNode *next) : val(x), next(next) {}
 };

class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
       multiset<int>mys;
       ListNode* temp = list1;
       if(list1 == nullptr && list2 == nullptr)
       return list1;

       else if(list1 == nullptr)
    addNode(list2,mys);

       else if(list2 == nullptr)
    addNode(list1,mys);

       else{
        if (list1->val<= list2->val)
        {
          addNode(list1,mys);
          addNode(list2,mys);  
        }
        else
        {
          addNode(list2,mys);
          addNode(list1,mys);  
        }
        }
        return(addNodeToList(mys));} 

       void addNode(ListNode* listm,multiset<int>&mys){
        if(listm==nullptr)
        return;
        mys.insert(listm->val);
        addNode(listm->next,mys);
        return;
       }
       ListNode* addNodeToList(multiset<int>&mys){
        ListNode* head = nullptr;
        ListNode* tail = nullptr;
        ListNode* newNode;
        for (auto &&i : mys)
        {
        newNode = new ListNode(i);
            if (head ==nullptr)
        {
            head = newNode;
            tail = newNode;
            continue;
        }
        tail->next = newNode;
        tail = newNode;
        }
       return head; 
       }
};
